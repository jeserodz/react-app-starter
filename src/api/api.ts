/* tslint:disable */
/* eslint-disable */
/**
 * JSON Placeholder API
 * JSONPlaceholder is a free online REST API that you can use whenever you need some fake data. It\'s great for tutorials, testing new libraries, sharing code examples, ...
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    suite: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipcode: string;
    /**
     * 
     * @type {Geo}
     * @memberof Address
     */
    geo: Geo;
}
/**
 * 
 * @export
 * @interface Album
 */
export interface Album {
    /**
     * 
     * @type {number}
     * @memberof Album
     */
    userId: number;
    /**
     * 
     * @type {number}
     * @memberof Album
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    title: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    postId: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    body: string;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    catchPhrase: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    bs: string;
}
/**
 * 
 * @export
 * @interface Geo
 */
export interface Geo {
    /**
     * 
     * @type {string}
     * @memberof Geo
     */
    lat: string;
    /**
     * 
     * @type {string}
     * @memberof Geo
     */
    lng: string;
}
/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    albumId: number;
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    thumbnailUrl: string;
}
/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    userId: number;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    body: string;
}
/**
 * 
 * @export
 * @interface Todo
 */
export interface Todo {
    /**
     * 
     * @type {number}
     * @memberof Todo
     */
    userId: number;
    /**
     * 
     * @type {number}
     * @memberof Todo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Todo
     */
    title: string;
    /**
     * 
     * @type {boolean}
     * @memberof Todo
     */
    completed: boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {Address}
     * @memberof User
     */
    address: Address;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    website: string;
    /**
     * 
     * @type {Company}
     * @memberof User
     */
    company: Company;
}

/**
 * AlbumsApi - axios parameter creator
 * @export
 */
export const AlbumsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAlbum: async (album: Album, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'album' is not null or undefined
            if (album === null || album === undefined) {
                throw new RequiredError('album','Required parameter album was null or undefined when calling addAlbum.');
            }
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof album !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(album !== undefined ? album : {}) : (album || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAlbum.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfAlbum: async (id: number, album: Album, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfAlbum.');
            }
            // verify required parameter 'album' is not null or undefined
            if (album === null || album === undefined) {
                throw new RequiredError('album','Required parameter album was null or undefined when calling editPartOfAlbum.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof album !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(album !== undefined ? album : {}) : (album || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeAlbum: async (id: number, album: Album, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholeAlbum.');
            }
            // verify required parameter 'album' is not null or undefined
            if (album === null || album === undefined) {
                throw new RequiredError('album','Required parameter album was null or undefined when calling editWholeAlbum.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof album !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(album !== undefined ? album : {}) : (album || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumById.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all photos of specified album
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumPhotos: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumPhotos.');
            }
            const localVarPath = `/albums/{id}/photos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Without parameter retruns all albums. With \'userId\' returns albums of specified user.
         * @summary Returns all albums
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (userId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumsApi - functional programming interface
 * @export
 */
export const AlbumsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAlbum(album: Album, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).addAlbum(album, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).deleteAlbum(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfAlbum(id: number, album: Album, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).editPartOfAlbum(id, album, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholeAlbum(id: number, album: Album, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).editWholeAlbum(id, album, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getAlbumById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all photos of specified album
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumPhotos(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Photo>>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getAlbumPhotos(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Without parameter retruns all albums. With \'userId\' returns albums of specified user.
         * @summary Returns all albums
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(userId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Album>>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getAllAlbums(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlbumsApi - factory interface
 * @export
 */
export const AlbumsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAlbum(album: Album, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).addAlbum(album, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: number, options?: any): AxiosPromise<void> {
            return AlbumsApiFp(configuration).deleteAlbum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfAlbum(id: number, album: Album, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).editPartOfAlbum(id, album, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing album with defined ID
         * @param {number} id ID of album
         * @param {Album} album 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeAlbum(id: number, album: Album, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).editWholeAlbum(id, album, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get album with defined ID
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumById(id: number, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).getAlbumById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all photos of specified album
         * @param {number} id ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumPhotos(id: number, options?: any): AxiosPromise<Array<Photo>> {
            return AlbumsApiFp(configuration).getAlbumPhotos(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Without parameter retruns all albums. With \'userId\' returns albums of specified user.
         * @summary Returns all albums
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(userId?: number, options?: any): AxiosPromise<Array<Album>> {
            return AlbumsApiFp(configuration).getAllAlbums(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlbumsApi - object-oriented interface
 * @export
 * @class AlbumsApi
 * @extends {BaseAPI}
 */
export class AlbumsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new album
     * @param {Album} album 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public addAlbum(album: Album, options?: any) {
        return AlbumsApiFp(this.configuration).addAlbum(album, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete album with defined ID
     * @param {number} id ID of album
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public deleteAlbum(id: number, options?: any) {
        return AlbumsApiFp(this.configuration).deleteAlbum(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing album with defined ID
     * @param {number} id ID of album
     * @param {Album} album 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public editPartOfAlbum(id: number, album: Album, options?: any) {
        return AlbumsApiFp(this.configuration).editPartOfAlbum(id, album, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing album with defined ID
     * @param {number} id ID of album
     * @param {Album} album 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public editWholeAlbum(id: number, album: Album, options?: any) {
        return AlbumsApiFp(this.configuration).editWholeAlbum(id, album, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get album with defined ID
     * @param {number} id ID of album
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getAlbumById(id: number, options?: any) {
        return AlbumsApiFp(this.configuration).getAlbumById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all photos of specified album
     * @param {number} id ID of album
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getAlbumPhotos(id: number, options?: any) {
        return AlbumsApiFp(this.configuration).getAlbumPhotos(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without parameter retruns all albums. With \'userId\' returns albums of specified user.
     * @summary Returns all albums
     * @param {number} [userId] ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getAllAlbums(userId?: number, options?: any) {
        return AlbumsApiFp(this.configuration).getAllAlbums(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentsApi - axios parameter creator
 * @export
 */
export const CommentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling addComment.');
            }
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteComment.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfComment: async (id: number, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfComment.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling editPartOfComment.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeComment: async (id: number, comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholeComment.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling editWholeComment.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof comment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(comment !== undefined ? comment : {}) : (comment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Without parameter retruns all comments. With \'postId\' returns comments of specified post.
         * @summary Returns all comments
         * @param {number} [postId] ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComments: async (postId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (postId !== undefined) {
                localVarQueryParameter['postId'] = postId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCommentById.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).addComment(comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).deleteComment(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfComment(id: number, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).editPartOfComment(id, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholeComment(id: number, comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).editWholeComment(id, comment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Without parameter retruns all comments. With \'postId\' returns comments of specified post.
         * @summary Returns all comments
         * @param {number} [postId] ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllComments(postId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).getAllComments(postId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await CommentsApiAxiosParamCreator(configuration).getCommentById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(comment: Comment, options?: any): AxiosPromise<Comment> {
            return CommentsApiFp(configuration).addComment(comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: number, options?: any): AxiosPromise<void> {
            return CommentsApiFp(configuration).deleteComment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfComment(id: number, comment: Comment, options?: any): AxiosPromise<Comment> {
            return CommentsApiFp(configuration).editPartOfComment(id, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing comment with defined ID
         * @param {number} id ID of comment
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeComment(id: number, comment: Comment, options?: any): AxiosPromise<Comment> {
            return CommentsApiFp(configuration).editWholeComment(id, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Without parameter retruns all comments. With \'postId\' returns comments of specified post.
         * @summary Returns all comments
         * @param {number} [postId] ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComments(postId?: number, options?: any): AxiosPromise<Array<Comment>> {
            return CommentsApiFp(configuration).getAllComments(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get comment with defined ID
         * @param {number} id ID of comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentById(id: number, options?: any): AxiosPromise<Comment> {
            return CommentsApiFp(configuration).getCommentById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new comment
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public addComment(comment: Comment, options?: any) {
        return CommentsApiFp(this.configuration).addComment(comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete comment with defined ID
     * @param {number} id ID of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public deleteComment(id: number, options?: any) {
        return CommentsApiFp(this.configuration).deleteComment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing comment with defined ID
     * @param {number} id ID of comment
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public editPartOfComment(id: number, comment: Comment, options?: any) {
        return CommentsApiFp(this.configuration).editPartOfComment(id, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing comment with defined ID
     * @param {number} id ID of comment
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public editWholeComment(id: number, comment: Comment, options?: any) {
        return CommentsApiFp(this.configuration).editWholeComment(id, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without parameter retruns all comments. With \'postId\' returns comments of specified post.
     * @summary Returns all comments
     * @param {number} [postId] ID of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public getAllComments(postId?: number, options?: any) {
        return CommentsApiFp(this.configuration).getAllComments(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get comment with defined ID
     * @param {number} id ID of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public getCommentById(id: number, options?: any) {
        return CommentsApiFp(this.configuration).getCommentById(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhotosApi - axios parameter creator
 * @export
 */
export const PhotosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPhoto: async (photo: Photo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'photo' is not null or undefined
            if (photo === null || photo === undefined) {
                throw new RequiredError('photo','Required parameter photo was null or undefined when calling addPhoto.');
            }
            const localVarPath = `/photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof photo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(photo !== undefined ? photo : {}) : (photo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePhoto.');
            }
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfPhoto: async (id: number, photo: Photo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfPhoto.');
            }
            // verify required parameter 'photo' is not null or undefined
            if (photo === null || photo === undefined) {
                throw new RequiredError('photo','Required parameter photo was null or undefined when calling editPartOfPhoto.');
            }
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof photo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(photo !== undefined ? photo : {}) : (photo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholePhoto: async (id: number, photo: Photo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholePhoto.');
            }
            // verify required parameter 'photo' is not null or undefined
            if (photo === null || photo === undefined) {
                throw new RequiredError('photo','Required parameter photo was null or undefined when calling editWholePhoto.');
            }
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof photo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(photo !== undefined ? photo : {}) : (photo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Without parameter returns all photos. With \'albumId\' returns photos of specified album.
         * @summary Returns all photos
         * @param {number} [albumId] ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos: async (albumId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (albumId !== undefined) {
                localVarQueryParameter['albumId'] = albumId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPhotoById.');
            }
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotosApi - functional programming interface
 * @export
 */
export const PhotosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPhoto(photo: Photo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).addPhoto(photo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoto(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).deletePhoto(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfPhoto(id: number, photo: Photo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).editPartOfPhoto(id, photo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholePhoto(id: number, photo: Photo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).editWholePhoto(id, photo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Without parameter returns all photos. With \'albumId\' returns photos of specified album.
         * @summary Returns all photos
         * @param {number} [albumId] ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPhotos(albumId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Photo>>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).getAllPhotos(albumId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhotoById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).getPhotoById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PhotosApi - factory interface
 * @export
 */
export const PhotosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPhoto(photo: Photo, options?: any): AxiosPromise<Photo> {
            return PhotosApiFp(configuration).addPhoto(photo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto(id: number, options?: any): AxiosPromise<void> {
            return PhotosApiFp(configuration).deletePhoto(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfPhoto(id: number, photo: Photo, options?: any): AxiosPromise<Photo> {
            return PhotosApiFp(configuration).editPartOfPhoto(id, photo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing photo with defined ID
         * @param {number} id ID of photo
         * @param {Photo} photo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholePhoto(id: number, photo: Photo, options?: any): AxiosPromise<Photo> {
            return PhotosApiFp(configuration).editWholePhoto(id, photo, options).then((request) => request(axios, basePath));
        },
        /**
         * Without parameter returns all photos. With \'albumId\' returns photos of specified album.
         * @summary Returns all photos
         * @param {number} [albumId] ID of album
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos(albumId?: number, options?: any): AxiosPromise<Array<Photo>> {
            return PhotosApiFp(configuration).getAllPhotos(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get photo with defined ID
         * @param {number} id ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhotoById(id: number, options?: any): AxiosPromise<Photo> {
            return PhotosApiFp(configuration).getPhotoById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhotosApi - object-oriented interface
 * @export
 * @class PhotosApi
 * @extends {BaseAPI}
 */
export class PhotosApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new photo
     * @param {Photo} photo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public addPhoto(photo: Photo, options?: any) {
        return PhotosApiFp(this.configuration).addPhoto(photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete photo with defined ID
     * @param {number} id ID of photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public deletePhoto(id: number, options?: any) {
        return PhotosApiFp(this.configuration).deletePhoto(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing photo with defined ID
     * @param {number} id ID of photo
     * @param {Photo} photo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public editPartOfPhoto(id: number, photo: Photo, options?: any) {
        return PhotosApiFp(this.configuration).editPartOfPhoto(id, photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing photo with defined ID
     * @param {number} id ID of photo
     * @param {Photo} photo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public editWholePhoto(id: number, photo: Photo, options?: any) {
        return PhotosApiFp(this.configuration).editWholePhoto(id, photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without parameter returns all photos. With \'albumId\' returns photos of specified album.
     * @summary Returns all photos
     * @param {number} [albumId] ID of album
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public getAllPhotos(albumId?: number, options?: any) {
        return PhotosApiFp(this.configuration).getAllPhotos(albumId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get photo with defined ID
     * @param {number} id ID of photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public getPhotoById(id: number, options?: any) {
        return PhotosApiFp(this.configuration).getPhotoById(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost: async (post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling addPost.');
            }
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof post !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(post !== undefined ? post : {}) : (post || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePost.');
            }
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfPost: async (id: number, post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfPost.');
            }
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling editPartOfPost.');
            }
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof post !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(post !== undefined ? post : {}) : (post || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholePost: async (id: number, post: Post, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholePost.');
            }
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling editWholePost.');
            }
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof post !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(post !== undefined ? post : {}) : (post || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Without parameter retruns all posts. With \'userId\' returns posts of specified user.
         * @summary Returns all posts
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (userId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPostById.');
            }
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all comments of specified post
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostComments: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPostComments.');
            }
            const localVarPath = `/posts/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPost(post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).addPost(post, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePost(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).deletePost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfPost(id: number, post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).editPartOfPost(id, post, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholePost(id: number, post: Post, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).editWholePost(id, post, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Without parameter retruns all posts. With \'userId\' returns posts of specified user.
         * @summary Returns all posts
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(userId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).getAllPosts(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).getPostById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all comments of specified post
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostComments(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await PostsApiAxiosParamCreator(configuration).getPostComments(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost(post: Post, options?: any): AxiosPromise<Post> {
            return PostsApiFp(configuration).addPost(post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost(id: number, options?: any): AxiosPromise<void> {
            return PostsApiFp(configuration).deletePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfPost(id: number, post: Post, options?: any): AxiosPromise<Post> {
            return PostsApiFp(configuration).editPartOfPost(id, post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing post with defined ID
         * @param {number} id ID of post
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholePost(id: number, post: Post, options?: any): AxiosPromise<Post> {
            return PostsApiFp(configuration).editWholePost(id, post, options).then((request) => request(axios, basePath));
        },
        /**
         * Without parameter retruns all posts. With \'userId\' returns posts of specified user.
         * @summary Returns all posts
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(userId?: number, options?: any): AxiosPromise<Array<Post>> {
            return PostsApiFp(configuration).getAllPosts(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get post with defined ID
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(id: number, options?: any): AxiosPromise<Post> {
            return PostsApiFp(configuration).getPostById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all comments of specified post
         * @param {number} id ID of post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostComments(id: number, options?: any): AxiosPromise<Array<Comment>> {
            return PostsApiFp(configuration).getPostComments(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new post
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public addPost(post: Post, options?: any) {
        return PostsApiFp(this.configuration).addPost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete post with defined ID
     * @param {number} id ID of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public deletePost(id: number, options?: any) {
        return PostsApiFp(this.configuration).deletePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing post with defined ID
     * @param {number} id ID of post
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public editPartOfPost(id: number, post: Post, options?: any) {
        return PostsApiFp(this.configuration).editPartOfPost(id, post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing post with defined ID
     * @param {number} id ID of post
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public editWholePost(id: number, post: Post, options?: any) {
        return PostsApiFp(this.configuration).editWholePost(id, post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without parameter retruns all posts. With \'userId\' returns posts of specified user.
     * @summary Returns all posts
     * @param {number} [userId] ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getAllPosts(userId?: number, options?: any) {
        return PostsApiFp(this.configuration).getAllPosts(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get post with defined ID
     * @param {number} id ID of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getPostById(id: number, options?: any) {
        return PostsApiFp(this.configuration).getPostById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all comments of specified post
     * @param {number} id ID of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getPostComments(id: number, options?: any) {
        return PostsApiFp(this.configuration).getPostComments(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TodosApi - axios parameter creator
 * @export
 */
export const TodosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTodo: async (todo: Todo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'todo' is not null or undefined
            if (todo === null || todo === undefined) {
                throw new RequiredError('todo','Required parameter todo was null or undefined when calling addTodo.');
            }
            const localVarPath = `/todos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof todo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(todo !== undefined ? todo : {}) : (todo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTodo: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTodo.');
            }
            const localVarPath = `/todos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfTodo: async (id: number, todo: Todo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfTodo.');
            }
            // verify required parameter 'todo' is not null or undefined
            if (todo === null || todo === undefined) {
                throw new RequiredError('todo','Required parameter todo was null or undefined when calling editPartOfTodo.');
            }
            const localVarPath = `/todos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof todo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(todo !== undefined ? todo : {}) : (todo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeTodo: async (id: number, todo: Todo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholeTodo.');
            }
            // verify required parameter 'todo' is not null or undefined
            if (todo === null || todo === undefined) {
                throw new RequiredError('todo','Required parameter todo was null or undefined when calling editWholeTodo.');
            }
            const localVarPath = `/todos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof todo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(todo !== undefined ? todo : {}) : (todo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Without parameter returns all todos. With \'userId\' returns todos of specified user.
         * @summary Returns all todos
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTodos: async (userId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/todos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTodoById.');
            }
            const localVarPath = `/todos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TodosApi - functional programming interface
 * @export
 */
export const TodosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTodo(todo: Todo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Todo>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).addTodo(todo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTodo(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).deleteTodo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfTodo(id: number, todo: Todo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Todo>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).editPartOfTodo(id, todo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholeTodo(id: number, todo: Todo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Todo>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).editWholeTodo(id, todo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Without parameter returns all todos. With \'userId\' returns todos of specified user.
         * @summary Returns all todos
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTodos(userId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Todo>>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).getAllTodos(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodoById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Todo>> {
            const localVarAxiosArgs = await TodosApiAxiosParamCreator(configuration).getTodoById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TodosApi - factory interface
 * @export
 */
export const TodosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTodo(todo: Todo, options?: any): AxiosPromise<Todo> {
            return TodosApiFp(configuration).addTodo(todo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTodo(id: number, options?: any): AxiosPromise<void> {
            return TodosApiFp(configuration).deleteTodo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfTodo(id: number, todo: Todo, options?: any): AxiosPromise<Todo> {
            return TodosApiFp(configuration).editPartOfTodo(id, todo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing todo with defined ID
         * @param {number} id ID of todo
         * @param {Todo} todo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeTodo(id: number, todo: Todo, options?: any): AxiosPromise<Todo> {
            return TodosApiFp(configuration).editWholeTodo(id, todo, options).then((request) => request(axios, basePath));
        },
        /**
         * Without parameter returns all todos. With \'userId\' returns todos of specified user.
         * @summary Returns all todos
         * @param {number} [userId] ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTodos(userId?: number, options?: any): AxiosPromise<Array<Todo>> {
            return TodosApiFp(configuration).getAllTodos(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get todo with defined ID
         * @param {number} id ID of todo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoById(id: number, options?: any): AxiosPromise<Todo> {
            return TodosApiFp(configuration).getTodoById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TodosApi - object-oriented interface
 * @export
 * @class TodosApi
 * @extends {BaseAPI}
 */
export class TodosApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new todo
     * @param {Todo} todo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public addTodo(todo: Todo, options?: any) {
        return TodosApiFp(this.configuration).addTodo(todo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete todo with defined ID
     * @param {number} id ID of todo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public deleteTodo(id: number, options?: any) {
        return TodosApiFp(this.configuration).deleteTodo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing todo with defined ID
     * @param {number} id ID of todo
     * @param {Todo} todo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public editPartOfTodo(id: number, todo: Todo, options?: any) {
        return TodosApiFp(this.configuration).editPartOfTodo(id, todo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing todo with defined ID
     * @param {number} id ID of todo
     * @param {Todo} todo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public editWholeTodo(id: number, todo: Todo, options?: any) {
        return TodosApiFp(this.configuration).editWholeTodo(id, todo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without parameter returns all todos. With \'userId\' returns todos of specified user.
     * @summary Returns all todos
     * @param {number} [userId] ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public getAllTodos(userId?: number, options?: any) {
        return TodosApiFp(this.configuration).getAllTodos(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get todo with defined ID
     * @param {number} id ID of todo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public getTodoById(id: number, options?: any) {
        return TodosApiFp(this.configuration).getTodoById(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling addUser.');
            }
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof user !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user !== undefined ? user : {}) : (user || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit part of existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfUser: async (id: number, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editPartOfUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling editPartOfUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof user !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user !== undefined ? user : {}) : (user || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeUser: async (id: number, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editWholeUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling editWholeUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof user !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user !== undefined ? user : {}) : (user || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all albums of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAlbums: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserAlbums.');
            }
            const localVarPath = `/users/{id}/albums`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserById.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all posts of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPosts: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserPosts.');
            }
            const localVarPath = `/users/{id}/posts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all todos of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTodos: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserTodos.');
            }
            const localVarPath = `/users/{id}/todos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).addUser(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit part of existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPartOfUser(id: number, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).editPartOfUser(id, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Edit existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editWholeUser(id: number, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).editWholeUser(id, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getAllUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all albums of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAlbums(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Album>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserAlbums(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all posts of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPosts(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserPosts(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return all todos of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTodos(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Todo>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserTodos(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a new user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(user: User, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).addUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit part of existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPartOfUser(id: number, user: User, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).editPartOfUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing user with defined ID
         * @param {number} id ID of user
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWholeUser(id: number, user: User, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).editWholeUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): AxiosPromise<Array<User>> {
            return UsersApiFp(configuration).getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all albums of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAlbums(id: number, options?: any): AxiosPromise<Array<Album>> {
            return UsersApiFp(configuration).getUserAlbums(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user with defined ID
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all posts of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPosts(id: number, options?: any): AxiosPromise<Array<Post>> {
            return UsersApiFp(configuration).getUserPosts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all todos of specified user
         * @param {number} id ID of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTodos(id: number, options?: any): AxiosPromise<Array<Todo>> {
            return UsersApiFp(configuration).getUserTodos(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new user
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(user: User, options?: any) {
        return UsersApiFp(this.configuration).addUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user with defined ID
     * @param {number} id ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit part of existing user with defined ID
     * @param {number} id ID of user
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editPartOfUser(id: number, user: User, options?: any) {
        return UsersApiFp(this.configuration).editPartOfUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing user with defined ID
     * @param {number} id ID of user
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editWholeUser(id: number, user: User, options?: any) {
        return UsersApiFp(this.configuration).editWholeUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(options?: any) {
        return UsersApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all albums of specified user
     * @param {number} id ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAlbums(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserAlbums(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user with defined ID
     * @param {number} id ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all posts of specified user
     * @param {number} id ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserPosts(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserPosts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all todos of specified user
     * @param {number} id ID of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserTodos(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserTodos(id, options).then((request) => request(this.axios, this.basePath));
    }
}


